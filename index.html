<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Тетрис</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* ========================================
        Новый Дизайн "Тетрис"
        ======================================== */
        :root {
            --bg-gradient-start: #0f0c29;
            --bg-gradient-mid: #302b63;
            --bg-gradient-end: #24243e;
            --glass-bg: rgba(22, 27, 34, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #e6edf3;
            --text-secondary: #7d8590;
            --text-accent: #58a6ff;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --btn-bg-start: #58a6ff;
            --btn-bg-end: #3b82f6;
            --btn-hover-start: #68b6ff;
            --btn-hover-end: #4b92f6;
            --btn-text: #ffffff;
            --control-bg: rgba(255, 255, 255, 0.1);
            --control-active-bg: rgba(255, 255, 255, 0.2);
            --grid-color: rgba(255, 255, 255, 0.05);
            --ghost-color: rgba(255, 255, 255, 0.15);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(45deg, var(--bg-gradient-start), var(--bg-gradient-mid), var(--bg-gradient-end));
            background-size: 200% 200%;
            animation: gradient-animation 15s ease infinite;
            color: var(--text-primary);
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* ========================================
        Структура Игры
        ======================================== */
        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 20px;
        }

        #game-container {
            display: flex;
            flex-direction: row-reverse;
            gap: 20px;
            padding: 25px;
            border-radius: 20px;
            transition: transform 0.5s ease;
            transform-origin: center center;
        }
        
        #main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #canvas {
            width: 200px;
            height: 440px;
            background-color: rgba(0,0,0,0.2);
            position: relative;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            transition: background-color 0.3s, border-color 0.3s;
            background-image: 
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
        }

        #canvas h1 {
            margin: 0;
            text-align: center;
            font-size: 16px;
            line-height: 1.5;
            padding: 20px;
            padding-top: 150px;
            color: var(--text-accent);
            font-weight: 600;
        }

        /* ========================================
        Информационная Панель
        ======================================== */
        #info-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 160px;
            text-align: center;
        }

        .info-box {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 12px 8px;
            transition: background-color 0.2s;
        }
        .info-box p {
            margin: 0;
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }
        .info-box span {
            display: block;
            font-size: 22px;
            color: var(--text-primary);
            margin-top: 5px;
            font-weight: 700;
        }

        #next_shape {
            position: relative;
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* ========================================
        Фигуры и Эффекты
        ======================================== */
        .square {
            position: absolute;
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            border-radius: 4px;
            transition: opacity 0.2s, transform 0.2s, top 0.08s linear, left 0.08s linear;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.4);
        }
        .square.ghost {
            background-color: transparent !important;
            box-shadow: none;
            border: 2px solid var(--ghost-color);
        }
        .square.line-clear {
            animation: flash 0.3s ease-out;
        }
        .square.bomb-clear {
            animation: bomb-flash 0.4s ease-out;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; transform: scale(1); filter: brightness(1.5); }
            50% { opacity: 0; transform: scale(0.5); filter: brightness(1); }
        }
        @keyframes bomb-flash {
            0% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        .type0 { background: linear-gradient(135deg, #c0392b, #e74c3c); } /* Z - Red */
        .type1 { background: linear-gradient(135deg, #27ae60, #2ecc71); } /* S - Green */
        .type2 { background: linear-gradient(135deg, #d35400, #f39c12); } /* L - Orange */
        .type3 { background: linear-gradient(135deg, #2980b9, #3498db); } /* J - Blue */
        .type4 { background: linear-gradient(135deg, #8e44ad, #9b59b6); } /* T - Purple */
        .type5 { background: linear-gradient(135deg, #2c3e50, #34495e); } /* O - Gray */
        .type6 { background: linear-gradient(135deg, #00b8d4, #00e5ff); } /* I - Cyan */
        .type7 { background: radial-gradient(circle, #f1c40f, #f39c12); box-shadow: 0 0 10px #f1c40f; } /* BOMB - Yellow */


        /* ========================================
        Модальные Окна (Меню)
        ======================================== */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }

        .modal-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            text-align: center;
            padding: 40px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            border-radius: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-content h1 {
            font-size: 3em;
            margin: 0 0 20px 0;
            font-weight: 700;
            letter-spacing: 2px;
        }
        .modal-content h1 span {
            text-shadow: 0 0 10px currentColor;
        }

        .btn {
            background: linear-gradient(45deg, var(--btn-bg-start), var(--btn-bg-end));
            color: var(--btn-text);
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            padding: 14px 28px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            width: 250px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid var(--glass-border);
        }
        .btn:hover {
            background: linear-gradient(45deg, var(--btn-hover-start), var(--btn-hover-end));
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(88, 166, 255, 0.4);
        }
        .btn:active {
            transform: translateY(0px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .rules-content, .stats-content {
            font-size: 13px;
            text-align: left;
            line-height: 1.8;
            width: 100%;
            max-width: 350px;
            color: var(--text-secondary);
        }
        .rules-content h3 {
            color: var(--text-accent);
            font-size: 15px;
            margin: 15px 0 5px 0;
            font-weight: 600;
        }

        .stat-category {
            margin-bottom: 20px;
        }
        .stat-category h3 {
            color: var(--text-accent);
            font-size: 16px;
            margin: 0 0 10px 0;
            text-align: center;
            font-weight: 600;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            background: rgba(0,0,0,0.15);
            padding: 8px 12px;
            border-radius: 8px;
        }
        .stat-item span:last-child {
            color: var(--text-primary);
            font-weight: bold;
        }

        /* ========================================
        Мобильное Управление
        ======================================== */
        #mobile-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left down right";
            gap: 10px;
            width: 200px;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            font-size: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--control-bg);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.2s;
        }
        .control-btn:active {
            background-color: var(--control-active-bg);
            transform: scale(0.95);
        }
        #rotate-btn { grid-area: up; }
        #left-btn { grid-area: left; }
        #down-btn { grid-area: down; }
        #right-btn { grid-area: right; }
        
        .hidden { display: none !important; }

        @media (max-width: 480px), (max-height: 700px) {
            #game-container {
                flex-direction: column;
                align-items: center;
            }
             #info-panel {
                flex-direction: row;
                flex-wrap: wrap;
                width: auto;
                justify-content: center;
            }
            .info-box {
                flex-grow: 1;
                min-width: 100px;
            }
            #info-panel #pause-btn-container {
                width: 100%;
                order: 5;
            }
        }

    </style>
</head>
<body oncontextmenu="return false;">

    <div id="main-menu" class="modal-overlay visible">
        <div class="modal-content">
            <h1>
                <span style="color: #e74c3c;">Т</span><span style="color: #f39c12;">е</span><span style="color: #2ecc71;">т</span><span style="color: #3498db;">р</span><span style="color: #9b59b6;">и</span><span style="color: #00e5ff;">с</span>
            </h1>
            <button class="btn" data-mode="classic">Классика</button>
            <button class="btn" data-mode="avalanche">Лавина</button>
            <button class="btn" data-mode="demolition">Подрывник</button>
            <button id="rules-btn" class="btn" style="margin-top: 10px;">Правила</button>
            <button id="stats-btn" class="btn">Статистика</button>
        </div>
    </div>

    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content">
            <h1>Правила</h1>
            <div class="rules-content">
                <h3>Классика</h3>
                <p>Собирайте линии, чтобы набрать очки. Каждые 10 линий увеличивают уровень и скорость игры.</p>
                <h3>Лавина</h3>
                <p>Каждые несколько секунд снизу поднимается новый ряд блоков. Успевайте их разбирать, пока поле не заполнилось!</p>
                <h3>Подрывник</h3>
                <p>Среди фигур иногда попадаются бомбы. Установите бомбу, чтобы взорвать блоки в радиусе 3x3. Идеально для выхода из сложных ситуаций.</p>
            </div>
            <button id="close-rules-btn" class="btn">Понятно</button>
        </div>
    </div>

    <div id="game-over-menu" class="modal-overlay">
        <div class="modal-content">
            <h1 id="game-over-title">Конец Игры</h1>
            <button id="restart-gameover-btn" class="btn">Заново</button>
            <button id="main-menu-gameover-btn" class="btn">В меню</button>
        </div>
    </div>

    <div id="pause-menu" class="modal-overlay">
        <div class="modal-content">
            <h1>Пауза</h1>
            <button id="resume-btn" class="btn">Продолжить</button>
            <button id="restart-btn" class="btn">Заново</button>
            <button id="main-menu-btn" class="btn">В меню</button>
        </div>
    </div>

    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content">
            <h1>Статистика</h1>
            <div id="stats-grid" class="stats-content"></div>
            <button id="close-stats-btn" class="btn">Закрыть</button>
        </div>
    </div>

    <div id="game-wrapper" class="hidden">
        <div id="game-container">
            <div id="info-panel">
                <div class="info-box"><p>Счет</p><span id="score-val">0</span></div>
                <div class="info-box"><p>Уровень</p><span id="level-val">1</span></div>
                <div class="info-box"><p>Линии</p><span id="lines-val">0</span></div>
                <div class="info-box"><p>Время</p><span id="time-val">00:00</span></div>
                <div class="info-box"><p>Далее</p><div id="next_shape"></div></div>
                <div id="pause-btn-container" style="padding: 0; background: transparent; border: none;">
                    <button id="pause-btn" class="btn" style="width: 100%; font-size: 12px; padding: 12px;">Пауза</button>
                </div>
            </div>
            <div id="main-content">
                <div id="canvas"></div>
                <div id="mobile-controls">
                    <button id="rotate-btn" class="control-btn">↻</button>
                    <button id="left-btn" class="control-btn">←</button>
                    <button id="down-btn" class="control-btn">↓</button>
                    <button id="right-btn" class="control-btn">→</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function () {
        // --- Все элементы UI ---
        const elements = {
            mainMenu: document.getElementById('main-menu'),
            pauseMenu: document.getElementById('pause-menu'),
            gameOverMenu: document.getElementById('game-over-menu'),
            statsModal: document.getElementById('stats-modal'),
            rulesModal: document.getElementById('rules-modal'),
            gameWrapper: document.getElementById('game-wrapper'),
            statsBtn: document.getElementById('stats-btn'),
            rulesBtn: document.getElementById('rules-btn'),
            closeStatsBtn: document.getElementById('close-stats-btn'),
            closeRulesBtn: document.getElementById('close-rules-btn'),
            resumeBtn: document.getElementById('resume-btn'),
            restartBtn: document.getElementById('restart-btn'),
            mainMenuBtn: document.getElementById('main-menu-btn'),
            pauseBtn: document.getElementById('pause-btn'),
            restartGameOverBtn: document.getElementById('restart-gameover-btn'),
            mainMenuGameOverBtn: document.getElementById('main-menu-gameover-btn'),
            gameOverTitle: document.getElementById('game-over-title'),
            canvas: document.getElementById('canvas'),
            nextShapeDisplay: document.getElementById("next_shape"),
            displays: {
                score: document.getElementById("score-val"),
                level: document.getElementById("level-val"),
                lines: document.getElementById("lines-val"),
                time: document.getElementById("time-val"),
            }
        };

        // --- VK Integration ---
        let isVK = false;
        const STATS_VK_KEY = 'tetrisGameStats_v3'; // Increased version for new stats

        async function initVK() {
            try {
                await vkBridge.send('VKWebAppInit');
                isVK = true;
                console.log('VK Bridge initialized');
                vkBridge.send("VKWebAppShowBannerAd", { banner_location: 'bottom' })
                    .catch(e => console.error("Banner Ad Init Error:", e));
            } catch (error) {
                console.error('VK Bridge init failed:', error);
                isVK = false;
            }
        }
        
        const tetris = {
            // --- Состояние игры ---
            board: [],
            sqs: [], 
            curSqs: [],
            ghostSqs: [],
            tempShapes: null,
            curShape: null,
            curShapeIndex: null,
            curX: 0,
            curY: 0,
            score: 0,
            level: 1,
            lines: 0,
            time: 0,
            speed: 700,
            gameMode: 'classic',
            maxLinesClearedInTurn: 0,
            
            // --- Флаги состояния ---
            isActive: false,
            isPaused: false,
            isGameOver: false,
            
            // --- Таймеры ---
            gameLoopTimeout: null,
            timeCounterInterval: null,
            avalancheTimeout: null,
            
            // --- Константы ---
            pSize: 20,
            boardHeight: 22,
            boardWidth: 10,
            spawnX: 4,
            spawnY: 0,
             shapes: [
                [[0,0],[-1,0],[0,-1],[1,-1]],// 0: Z Red
                [[0,0],[1,0],[0,-1],[-1,-1]],// 1: S Green
                [[0,0],[-1,0],[1,0],[-1,-1]],// 2: L Orange
                [[0,0],[-1,0],[1,0],[1,-1]], // 3: J Blue
                [[0,0],[-1,0],[1,0],[0,-1]], // 4: T Purple
                [[0,0],[0,-1],[1,0],[1,-1]], // 5: O Gray
                [[0,0],[-1,0],[1,0],[2,0]], // 6: I Cyan
                [[0,0]]                     // 7: BOMB
            ],
            
            init: function (mode) {
                this.gameMode = mode;
                this.cleanup();
                this.resetState();
                
                this.initBoard();
                this.updateInfo();
                this.initShapes();
                this.bindEvents();
                this.play();

                if (this.gameMode === 'avalanche') {
                    this.scheduleAvalanche();
                }
            },

            cleanup: function() {
                this.clearTimers();
                this.unbindEvents();
                elements.canvas.innerHTML = '';
            },

            resetState: function() {
                this.board = []; this.sqs = []; this.curSqs = [];
                this.tempShapes = null;
                this.score = 0; this.level = 1; this.lines = 0; this.time = 0; this.speed = 700;
                this.maxLinesClearedInTurn = 0;
                this.isActive = true; this.isPaused = false; this.isGameOver = false;

                if (this.gameMode === 'demolition') {
                    elements.displays.level.parentElement.style.display = 'none';
                } else {
                    elements.displays.level.parentElement.style.display = 'block';
                }
            },

            initBoard: function () {
                this.board = Array(this.boardHeight).fill(0).map(() => Array(this.boardWidth).fill(null));
            },
            
            updateInfo: function() {
                elements.displays.score.textContent = this.score;
                elements.displays.level.textContent = this.level;
                elements.displays.lines.textContent = this.lines;
                elements.displays.time.textContent = this.formatTime(this.time);
            },
            
            formatTime: function(seconds) {
                const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                const sec = (seconds % 60).toString().padStart(2, '0');
                return `${min}:${sec}`;
            },

            initShapes: function () {
                if (!this.tempShapes || this.tempShapes.length <= 1) this.initTempShapes();
                else this.tempShapes.shift();
                
                this.curShapeIndex = this.tempShapes[0];
                this.curShape = JSON.parse(JSON.stringify(this.shapes[this.curShapeIndex]));
                this.initNextShape();

                let minY = 0;
                this.curShape.forEach(([, y]) => {
                    if (y < minY) minY = y;
                });

                this.setCurCoords(this.spawnX, -minY);

                if (this.checkMove(this.curX, this.curY, this.curShape)) {
                    this.drawShape();
                } else {
                    this.gameOver();
                }
            },
            initNextShape: function () {
                if (this.tempShapes.length <=1) this.initTempShapes();
                this.nextShapeIndex = this.tempShapes[1];
                this.drawNextShape();
            },
            initTempShapes: function () {
                let baseShapes = Array.from({length: this.shapes.length - 1}, (_, i) => i);
                this.tempShapes = [];
                for(let i = 0; i < 2; i++) { // Generate 2 sets of shapes
                     let tempSet = [...baseShapes];
                     for (let k = tempSet.length - 1; k > 0; k--) {
                        const j = Math.floor(Math.random() * (k + 1));
                        [tempSet[k], tempSet[j]] = [tempSet[j], tempSet[k]];
                     }
                     this.tempShapes.push(...tempSet);
                }

                if (this.gameMode === 'demolition' && Math.random() < 0.25) { // 25% chance for a bomb
                    this.tempShapes.splice(1, 0, 7); // Insert bomb as the next shape
                }
            },
            
            drawNextShape: function () {
                elements.nextShapeDisplay.innerHTML = "";
                const shape = this.shapes[this.nextShapeIndex];
                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                shape.forEach(([x, y]) => {
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                });
                const width = (maxX - minX + 1) * this.pSize;
                const height = (maxY - minY + 1) * this.pSize;
                const containerWidth = elements.nextShapeDisplay.clientWidth;
                const containerHeight = elements.nextShapeDisplay.clientHeight;

                const offsetX = (containerWidth - width) / 2; 
                const offsetY = (containerHeight - height) / 2;

                shape.forEach(point => {
                    const sq = this.createSquare(
                        (point[0] - minX) * this.pSize + offsetX, 
                        (point[1] - minY) * this.pSize + offsetY, 
                        this.nextShapeIndex
                    );
                    elements.nextShapeDisplay.appendChild(sq);
                });
            },
            drawShape: function () {
                this.removeSqs(this.curSqs);
                this.curSqs = [];
                this.curShape.forEach(point => {
                    const sqX = (point[0] + this.curX) * this.pSize;
                    const sqY = (point[1] + this.curY) * this.pSize;
                    this.curSqs.push(this.createSquare(sqX, sqY, this.curShapeIndex));
                });
                this.curSqs.forEach(sq => elements.canvas.appendChild(sq));
                
                if (this.gameMode !== 'demolition' || this.curShapeIndex !== 7) {
                     this.drawGhostShape();
                } else {
                    this.removeSqs(this.ghostSqs);
                    this.ghostSqs = [];
                }
            },
            drawGhostShape: function() {
                this.removeSqs(this.ghostSqs);
                this.ghostSqs = [];
                let ghostY = this.curY;
                while(this.checkMove(this.curX, ghostY + 1, this.curShape)) {
                    ghostY++;
                }

                this.curShape.forEach(point => {
                    const sqX = (point[0] + this.curX) * this.pSize;
                    const sqY = (point[1] + ghostY) * this.pSize;
                    const ghostSq = this.createSquare(sqX, sqY, this.curShapeIndex);
                    ghostSq.classList.add('ghost');
                    this.ghostSqs.push(ghostSq);
                });
                this.ghostSqs.forEach(sq => elements.canvas.appendChild(sq));
            },
            createSquare: function (x, y, type) {
                const el = document.createElement("div");
                el.className = "square type" + type;
                el.style.left = x + "px"; el.style.top = y + "px";
                return el;
            },
            removeSqs: function (sqsArray) {
                sqsArray.forEach(sq => sq.parentElement?.removeChild(sq));
            },
            setCurCoords: function (x, y) { this.curX = x; this.curY = y; },

            eventHandlers: {},
            bindEvents: function () {
                this.eventHandlers.keyDown = this.handleKey.bind(this);
                document.addEventListener("keydown", this.eventHandlers.keyDown);

                const controls = { 'left-btn': 'L', 'right-btn': 'R', 'down-btn': 'D', 'rotate-btn': 'RT' };
                this.eventHandlers.mobile = [];
                for (const [id, move] of Object.entries(controls)) {
                    const btn = document.getElementById(id);
                    let interval;
                    const startMove = (e) => {
                        e.preventDefault();
                        if (interval || this.isPaused || this.isGameOver) return;
                        this.move(move);
                        interval = setInterval(() => this.move(move), 120);
                    };
                    const endMove = () => { clearInterval(interval); interval = null; };
                    
                    btn.addEventListener('mousedown', startMove);
                    btn.addEventListener('touchstart', startMove, { passive: false });
                    btn.addEventListener('mouseup', endMove);
                    btn.addEventListener('mouseleave', endMove);
                    btn.addEventListener('touchend', endMove);

                    this.eventHandlers.mobile.push({btn, startMove, endMove});
                }
            },
            unbindEvents: function() {
                if (this.eventHandlers.keyDown) {
                    document.removeEventListener('keydown', this.eventHandlers.keyDown);
                    this.eventHandlers.keyDown = null;
                }
                if (this.eventHandlers.mobile) {
                    this.eventHandlers.mobile.forEach(({btn, startMove, endMove}) => {
                        btn.removeEventListener('mousedown', startMove);
                        btn.removeEventListener('touchstart', startMove);
                        btn.removeEventListener('mouseup', endMove);
                        btn.removeEventListener('mouseleave', endMove);
                        btn.removeEventListener('touchend', endMove);
                    });
                    this.eventHandlers.mobile = [];
                }
            },
            handleKey: function (e) {
                if (!this.isActive || this.isGameOver) return;
                if (e.keyCode === 27 || e.keyCode === 80) { 
                    e.preventDefault(); 
                    this.togglePause(); 
                    return; 
                }
                if(this.isPaused) return;

                switch (e.keyCode) {
                    case 37: case 65: e.preventDefault(); this.move("L"); break; // Left Arrow / A
                    case 38: case 87: e.preventDefault(); this.move("RT"); break; // Up Arrow / W
                    case 39: case 68: e.preventDefault(); this.move("R"); break; // Right Arrow / D
                    case 40: case 83: e.preventDefault(); this.move("D"); break; // Down Arrow / S
                }
            },
            gameOver: function () {
                this.clearTimers();
                this.isActive = false; this.isGameOver = true;
                
                let title = "Конец Игры";
                elements.gameOverTitle.textContent = title;
                elements.gameOverMenu.classList.add('visible');
                stats.save(this.gameMode, this.score, this.lines, this.time, this.level);

                if(isVK) {
                    vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'interstitial' })
                            .catch(e => console.error("Interstitial Ad Error:", e));
                }
            },
            play: function () {
                if (this.isGameOver) return;
                this.isActive = true; this.isPaused = false;
                this.startGameLoop();
                this.startTimeCounter();
            },
            togglePause: function () {
                if (this.isGameOver) return;
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    this.clearTimers();
                    elements.pauseMenu.classList.add('visible');
                } else {
                    elements.pauseMenu.classList.remove('visible');
                    this.play();
                }
            },
            startGameLoop: function() {
                this.gameLoopTimeout = setTimeout(() => this.gameLoop(), this.speed);
            },
            startTimeCounter: function() {
                this.timeCounterInterval = setInterval(() => {
                    this.time++;
                    this.updateInfo();
                }, 1000);
            },
            clearTimers: function () {
                clearTimeout(this.gameLoopTimeout);
                clearInterval(this.timeCounterInterval);
                clearTimeout(this.avalancheTimeout);
                this.gameLoopTimeout = null;
                this.timeCounterInterval = null;
                this.avalancheTimeout = null;
            },
            
            gameLoop: function() {
                if (this.isPaused || !this.isActive) return;
                
                let clearedRows = [];

                if (this.checkMove(this.curX, this.curY + 1, this.curShape)) {
                    this.curY++;
                    this.drawShape();
                } else {
                    if (this.curY < 0) {
                        this.gameOver();
                        return;
                    }

                    if (this.gameMode === 'demolition' && this.curShapeIndex === 7) {
                        this.detonateBomb(this.curX, this.curY);
                        return; // Skip normal placement logic
                    }

                    this.placeShape();
                    clearedRows = this.checkRows();
                    if (clearedRows.length === 0) {
                        this.calcScore({ shape: true });
                        this.checkLevelUp();
                        if(this.isGameOver) return;
                        this.initShapes();
                    }
                }

                if (!this.isGameOver && clearedRows.length === 0) {
                    this.startGameLoop();
                }
            },

            move: function (dir) {
                if (this.isPaused || this.isGameOver) return;
                let tempX = this.curX, tempY = this.curY;
                
                if (dir === "RT") { this.rotate(); return; }
                
                switch (dir) {
                    case "L": tempX--; break;
                    case "R": tempX++; break;
                    case "D": tempY++; break;
                }

                if (this.checkMove(tempX, tempY, this.curShape)) {
                    this.setCurCoords(tempX, tempY);
                    this.drawShape();
                    if (dir === 'D') {
                        this.calcScore({ softDrop: 1 });
                        clearTimeout(this.gameLoopTimeout);
                        this.startGameLoop();
                    }
                }
            },
            rotate: function () {
                if (this.curShapeIndex >= 5) return; // O-shape and Bomb don't rotate
                const tempShape = this.curShape.map(([x, y]) => [-y, x]);
                const kicks = [0, 1, -1, 2, -2];
                for (const kick of kicks) {
                    if (this.checkMove(this.curX + kick, this.curY, tempShape)) {
                        this.curX += kick;
                        this.curShape = tempShape;
                        this.drawShape();
                        return;
                    }
                }
            },
            checkMove: (x, y, p) => !tetris.isOB(x, y, p) && !tetris.isCollision(x, y, p),
            isCollision: function (x, y, p) {
                return p.some(([px, py]) => {
                    const newX = px + x, newY = py + y;
                    return newY >= 0 && this.board[newY]?.[newX] !== null;
                });
            },
            isOB: function (x, y, p) {
                return p.some(([px, py]) => {
                    const newX = px + x, newY = py + y;
                    return newX < 0 || newX >= this.boardWidth || newY >= this.boardHeight;
                });
            },
            
            placeShape: function() {
                this.markBoardShape(this.curX, this.curY, this.curShape);
                this.removeSqs(this.curSqs);
                this.removeSqs(this.ghostSqs);
                this.redrawAllBlocks();
            },
            markBoardShape: function (x, y, p) {
                p.forEach(([px, py]) => {
                    const boardY = py + y;
                    const boardX = px + x;
                    if (boardY >= 0) {
                        this.board[boardY][boardX] = this.curShapeIndex;
                    }
                });
            },
            checkRows: function () {
                let clearedRows = [];
                for (let y = this.boardHeight - 1; y >= 0; y--) {
                    if (this.isRowFull(y)) clearedRows.push(y);
                }
                if (clearedRows.length > 0) {
                    this.animateAndRemoveRows(clearedRows);
                }
                return clearedRows;
            },
            isRowFull: function(y) {
                return this.board[y].every(cell => cell !== null);
            },
            animateAndRemoveRows: function(rows) {
                this.maxLinesClearedInTurn = Math.max(this.maxLinesClearedInTurn, rows.length);

                rows.forEach(y => {
                    for (let x = 0; x < this.boardWidth; x++) {
                        const sqToRemove = this.sqs.find(sq => {
                            const [sqX, sqY] = this.getPos(sq);
                            return sqX === x && sqY === y;
                        });
                        sqToRemove?.classList.add('line-clear');
                    }
                });
                
                setTimeout(() => {
                    this.removeRows(rows);
                    this.calcScore({ lines: rows.length });
                    this.checkLevelUp();
                    if (!this.isGameOver) {
                        this.initShapes();
                        this.startGameLoop();
                    }
                }, 300);
            },
            removeRows: function(rowsToRemove) {
                rowsToRemove.sort((a, b) => a - b).forEach(y => {
                    this.board.splice(y, 1);
                    this.board.unshift(Array(this.boardWidth).fill(null));
                });
                this.redrawAllBlocks();
            },
            redrawAllBlocks: function() {
                this.removeSqs(this.sqs);
                this.sqs = [];
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        if (this.board[y][x] !== null) {
                            const type = this.board[y][x];
                            const sq = this.createSquare(x * this.pSize, y * this.pSize, type);
                            elements.canvas.appendChild(sq);
                            this.sqs.push(sq);
                        }
                    }
                }
            },
            getPos: (block) => [Math.round(parseInt(block.style.left)/tetris.pSize), Math.round(parseInt(block.style.top)/tetris.pSize)],

            calcScore: function (args) {
                const lines = args.lines || 0;
                if (lines > 0) {
                    const lineScores = [0, 40, 100, 300, 1200];
                    this.score += lineScores[lines] * this.level;
                    this.lines += lines;
                }
                if (args.shape) this.score += 5;
                if (args.softDrop) this.score += args.softDrop;
                if (args.bombClear) this.score += args.bombClear * 10;
                this.updateInfo();
            },
            checkLevelUp: function () {
                if (this.gameMode === 'classic' && this.lines >= this.level * 10) {
                   this.level++;
                   this.speed = Math.max(100, this.speed - 60);
                } else if (this.gameMode === 'avalanche') {
                    const newLevel = Math.floor(this.lines / 5) + 1;
                    if(newLevel > this.level) {
                        this.level = newLevel;
                    }
                }
                this.updateInfo();
            },

            // --- Avalanche Mode ---
            scheduleAvalanche: function() {
                if (this.isPaused || this.isGameOver) return;
                const interval = Math.max(3000, 10000 - (this.level * 500));
                this.avalancheTimeout = setTimeout(() => this.triggerAvalanche(), interval);
            },
            triggerAvalanche: function() {
                if (this.isPaused || this.isGameOver) return;
                // Shift every row up
                this.board.shift();
                
                // Add new garbage row at the bottom
                const newRow = Array(this.boardWidth).fill(5); // Gray blocks
                const emptySpot = Math.floor(Math.random() * this.boardWidth);
                newRow[emptySpot] = null;
                this.board.push(newRow);

                // Check for game over
                if (this.board[0].some(cell => cell !== null)) {
                    this.redrawAllBlocks();
                    this.gameOver();
                    return;
                }
                
                this.redrawAllBlocks();
                this.scheduleAvalanche();
            },

            // --- Demolition Mode ---
            detonateBomb: function(x, y) {
                this.removeSqs(this.curSqs);
                let clearedCount = 0;
                for(let i = -1; i <= 1; i++) {
                    for(let j = -1; j <= 1; j++) {
                        const checkX = x + j;
                        const checkY = y + i;
                        if(checkY >= 0 && checkY < this.boardHeight && checkX >=0 && checkX < this.boardWidth) {
                             if(this.board[checkY][checkX] !== null) {
                                this.board[checkY][checkX] = null;
                                clearedCount++;
                             }
                        }
                    }
                }
                
                this.redrawAllBlocks(); // Redraw once before animation
                this.sqs.forEach(sq => { // Find squares in blast radius to animate
                    const [sqX, sqY] = this.getPos(sq);
                     for(let i = -1; i <= 1; i++) {
                        for(let j = -1; j <= 1; j++) {
                           if(sqX === x+j && sqY === y+i) {
                               sq.classList.add('bomb-clear');
                           }
                        }
                    }
                });
                
                setTimeout(() => {
                    this.redrawAllBlocks();
                    this.calcScore({ bombClear: clearedCount });
                    this.initShapes();
                    this.startGameLoop();
                }, 400);
            }
        };

        const stats = {
            data: {},
            async load() {
                let loadedData = null;
                if (isVK) {
                    try {
                        const data = await vkBridge.send('VKWebAppStorageGet', { keys: [STATS_VK_KEY] });
                        if (data.keys[0].value) {
                            loadedData = data.keys[0].value;
                        }
                    } catch (e) { console.error('VK Storage load failed:', e); }
                }
                if (!loadedData) {
                    loadedData = localStorage.getItem(STATS_VK_KEY);
                }
                
                const defaultStats = {
                    classic: { highScore: 0, maxLevel: 0 },
                    avalanche: { highScore: 0, maxLines: 0 },
                    demolition: { highScore: 0, bestTime: Infinity }
                };

                this.data = loadedData ? JSON.parse(loadedData) : defaultStats;

                for (const mode in defaultStats) {
                    if (!this.data[mode]) {
                        this.data[mode] = defaultStats[mode];
                    }
                }
            },
            async save(mode, score, lines, time, level) {
                if (!this.data[mode]) return;
                
                if (mode === 'classic') {
                    this.data[mode].highScore = Math.max(this.data[mode].highScore, score);
                    this.data[mode].maxLevel = Math.max(this.data[mode].maxLevel, level);
                } else if (mode === 'avalanche') {
                    this.data[mode].highScore = Math.max(this.data[mode].highScore, score);
                    this.data[mode].maxLines = Math.max(this.data[mode].maxLines, lines);
                } else if (mode === 'demolition') {
                    this.data[mode].highScore = Math.max(this.data[mode].highScore, score);
                    if (lines >= 40) { // Win condition for demolition mode
                         this.data[mode].bestTime = Math.min(this.data[mode].bestTime, time);
                    }
                }
                
                const dataString = JSON.stringify(this.data);
                localStorage.setItem(STATS_VK_KEY, dataString);
                if (isVK) {
                    try {
                        await vkBridge.send('VKWebAppStorageSet', { key: STATS_VK_KEY, value: dataString });
                    } catch (e) { console.error('VK Storage save failed:', e); }
                }
            },
            display: function() {
                const grid = document.getElementById('stats-grid');
                grid.innerHTML = `
                    <div class="stat-category">
                        <h3>Классика</h3>
                        <div class="stat-item"><span>Рекорд:</span> <span>${this.data.classic.highScore}</span></div>
                        <div class="stat-item"><span>Макс. уровень:</span> <span>${this.data.classic.maxLevel}</span></div>
                    </div>
                    <div class="stat-category">
                        <h3>Лавина</h3>
                        <div class="stat-item"><span>Рекорд:</span> <span>${this.data.avalanche.highScore}</span></div>
                        <div class="stat-item"><span>Макс. линии:</span> <span>${this.data.avalanche.maxLines}</span></div>
                    </div>
                    <div class="stat-category">
                        <h3>Подрывник</h3>
                        <div class="stat-item"><span>Рекорд:</span> <span>${this.data.demolition.highScore}</span></div>
                        <div class="stat-item"><span>Лучшее время (40 линий):</span> <span>${this.data.demolition.bestTime === Infinity ? 'N/A' : tetris.formatTime(this.data.demolition.bestTime)}</span></div>
                    </div>`;
                elements.statsModal.classList.add('visible');
            }
        };
        
        function resizeGame() {
            const gameContainer = document.getElementById('game-container');
            if (!gameContainer || !gameContainer.offsetParent) return;

            const baseWidth = 420; 
            const baseHeight = 650; 
            
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let scale;

            if (viewportWidth < 480 || viewportHeight < 700) {
                 scale = Math.min(viewportWidth / 380, viewportHeight / 750);
            } else {
                 scale = Math.min(viewportWidth / baseWidth, viewportHeight / baseHeight);
            }
            
            if (scale > 1.2) scale = 1.2;

            gameContainer.style.transform = `scale(${scale})`;
        }

        async function initApp() {
            await initVK();
            await stats.load();

            elements.mainMenu.addEventListener('click', (e) => {
                if (e.target.matches('.btn[data-mode]')) {
                    elements.mainMenu.classList.remove('visible');
                    elements.gameWrapper.classList.remove('hidden');
                    tetris.init(e.target.dataset.mode);
                    resizeGame();
                }
            });
            elements.statsBtn.addEventListener('click', () => stats.display());
            elements.rulesBtn.addEventListener('click', () => elements.rulesModal.classList.add('visible'));
            elements.closeStatsBtn.addEventListener('click', () => elements.statsModal.classList.remove('visible'));
            elements.closeRulesBtn.addEventListener('click', () => elements.rulesModal.classList.remove('visible'));
            elements.pauseBtn.addEventListener('click', () => tetris.togglePause());
            elements.resumeBtn.addEventListener('click', () => tetris.togglePause());
            
            const restart = () => {
                elements.pauseMenu.classList.remove('visible');
                elements.gameOverMenu.classList.remove('visible');
                tetris.init(tetris.gameMode);
            };
            elements.restartBtn.addEventListener('click', restart);
            elements.restartGameOverBtn.addEventListener('click', restart);

            const toMainMenu = () => {
                tetris.cleanup();
                elements.pauseMenu.classList.remove('visible');
                elements.gameOverMenu.classList.remove('visible');
                elements.gameWrapper.classList.add('hidden');
                elements.mainMenu.classList.add('visible');
            };
            elements.mainMenuBtn.addEventListener('click', toMainMenu);
            elements.mainMenuGameOverBtn.addEventListener('click', toMainMenu);

            window.addEventListener('resize', resizeGame);
            resizeGame(); // Initial call
        }
        initApp();
    })();
    </script>
</body>
</html>

